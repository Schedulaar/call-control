%%
%% Author: markl
%% 2/26/2018
%%

% Preamble
\documentclass[11pt]{article}

% Packages
\usepackage{a4wide}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage[open]{bookmark}
\usepackage{amsmath}
\usepackage{colonequals}
\usepackage{xcolor}

\hypersetup{
colorlinks,
citecolor=black,
filecolor=black,
linkcolor=black,
urlcolor=black
}

\title{\bfseries Call-Control in Ringnetzwerken}
\author{Michael Markl}
\date{Seminar\\ \glqq Algorithmen und Datenstrukturen\grqq\\~ \\Sommersemester 2018\\~\\ Universität Augsburg}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\theoremstyle{theorem}
\newtheorem{lemma}{Lemma}[section]
\theoremstyle{theorem}
\newtheorem{theorem}{Theorem}[section]
\newcommand{\coloniff}{\vcentcolon\Longleftrightarrow}
\newcommand\todo[1]{\textcolor{red}{#1}}
\newcommand{\set}{\mathbb}
\newcommand{\find}{\text{\em find}}
\newcommand{\Mod}{~\mathrm{mod}~}



% Document
\begin{document}
    \pagenumbering{gobble}
    \maketitle
    \clearpage

    \pagenumbering{Roman}
    \tableofcontents

    \clearpage

    \setcounter{page}{1}
    \setcounter{section}{0}
    \pagenumbering{arabic}

    \section{Einführung}\label{sec:einführung}

    \begin{definition}[Call-Control-Problem]
        Sei $(V,E)$ ein ungerichteter Graph, dessen Kanten die Kapazitäten $c: E \to \mathbb{N}$ besitzen, und $P$ eine
        (Multi-)Menge von $m \in \mathbb{N}$ Pfaden in $(V,E)$.
        Eine Menge $Q \subseteq P$ heißt {\em geeignet}, falls für jede Kante $e \in E$ die Anzahl aller Pfade in $Q$,
        die $e$ enthalten, höchstens $c(e)$ ist.
        Die Pfade einer geeigneten Menge heißen $akzeptiert$.
        Das {\em Call-Control-Problem} besteht darin, die Anzahl der akzeptierten Pfade zu maximieren.
    \end{definition}

    Im Speziellen betrachten wir das Call-Control-Problem in Ringen und Ketten.
    Eine {\em Kette} ist ein ungerichteter Graph $(V,E)$, der nur aus den Kanten und Knoten eines Weges besteht.
    Ein {\em Ring} ist dabei ein ungerichteter Graph, der nur aus den Kanten und Knoten eines Zyklus' besteht.
    Betrachten wir einen Ring $(V,E)$ mit $V=\{0, \dots , n-1\}$ aufgezeichnet auf einer Ebene, bei dem die Knoten nach
    dem Uhrzeigersinn nummeriert werden, können wir jeden Pfad im Ring durch einen Anfangs- und Zielknoten identifizieren,
    wobei der Pfad vom Anfangsknoten aus im Uhrzeigersinn bis zum Zielknoten \glqq verläuft\grqq.
    Für einen Pfad $p$ in einem solchen Ring oder einer Kette, nennen wir $s_p$ den
    Anfangsknoten und $t_p$ den Zielknoten des Pfades und schreiben $p=(s_p, t_p)$.


    \subsection{Motivation und Anwendungen}\label{subsec:motivationUndAnwendungen}
    Diese Problemstellung findet seine Anwendung darin, in einem (Kommunikations-)Netzwerk mit festen Bandbreiten jeder
    Kante und einer gegebenen Menge an Anfragen möglichst viele dieser Anfragen zuzulassen, wobei jede Anfrage auf allen
    Kanten ihres Pfades genau eine Bandbreiteneinheit aufbraucht und keine Kante ihre Bandbreite überschreiten kann.

    Oft trifft man zwar auf die online-Variante des Problems, das heißt, dass jede Anfrage schon bei Eintreffen und
    ohne Wissen über künftige Anfragen akzeptiert oder abgelehnt werden muss.
    Jedoch sind die Erkenntnisse über das offline-Problem auch hier relevant, um eine entsprechende Lösung für das
    online-Problem entwerfen zu können.
    Außerdem kann die optimale Lösung des offline-Problems als Vergleichspunkt bei der Bewertung von Lösungen des
    online-Problems genutzt werden.

    Eine Anwendung bietet das Problem der zyklischen Ablaufplanung:

    \todo{Kette ist schon durchnummeriert definiert}

	\section{Optimale Lösung des Call-Control-Problems in Ketten}\label{sec:call-control-in-chains}
	\input{call-control-in-chains}

    \section{Lösung in Ringen}\label{sec:call-control-in-rings}
    Nachdem wir das Call-Control-Problem in Ketten optimal lösen können, betrachten wir nun das Problem in Ringen.
    Sei also $(V, E)$ ein Ring mit $V=\{0,\dots,n-1 \}\}$ und $E=\{e_0, \dots, e_{n-1}\}$, wobei $e_i$ die
    Knoten $i$ und $(i+1 \Mod n)$ verbindet.
    Außerdem haben wir eine Menge $P=\{p_1, \dots, p_m\}$ an Pfaden gegeben, unter denen jeder Pfad $p$ einen
    Anfangsknoten $s_p$ mit einem Zielknoten $t_p$ verbindet mit $s_p \neq t_p$.
    Dabei enthält der Pfad alle Kanten, auf die man trifft, wenn man sich vom Anfangsknoten im Uhrzeigersinn - das heißt
    bis auf $\mathrm{mod}~n$ mit aufsteigenden Knotennamen - zum Zielknoten bewegt.
    Alle Knoten eines Pfades bis auf den Anfangs- und Zielknoten heißen {\em innere Knoten}.
    Außerdem können wir ohne Einschränkung von $n \leq 2m$ ausgehen, da wir solche Knoten entfernen können, die nicht
    Anfangs- oder Zielknoten eines Pfades sind.
    Dabei ersetzen wir die zwei Kanten, die am zu entfernenden Knoten anliegen, durch eine einzige Kante, dessen
    Kapazität das Minimum der vorherigen beiden ist.
    \todo{FIGURE} zeigt ein Beispiel eines Rings (innen) mit den gegebenen Pfaden (außen).

    \todo{check if feasible set is defined}

    Das Call-Control-Problem beschreibt hier wieder das Problem, eine möglichst große geeignete Teilmenge
    $Q \subseteq P$ zu finden.
    Dazu teilen wir die Menge der Pfade $P$ in zwei disjunkte Teilmengen $P_1$ und $P_2$.
    Dabei bildet $P_1$ die Menge der Pfade in $P$, die den ersten Knoten $v_0$ nicht als inneren Knoten haben, $P_2$
    beinhaltet die restlichen Pfade, also $P \setminus P_1$.
    Diese Partition können wir ganz einfach berechnen:
    Sagen wir, dass jeder Pfad, dessen Zielknoten $0$ ist, eigentlich den Zielknoten $n$ hat, so können wir durch alle
    Pfade $p$ iterieren und falls $s_p < t_p$ gilt, so ist $0$ kein innerer Knoten von $p$ und wird daher $P_1$
    zugeordnet, sonst $P_2$.












    \section{Gewichtetes Call-Control-Problem}\label{sec:weiteres}
    - WeightedCallProblem: CallProblem mit Gewichten 1


\end{document}
