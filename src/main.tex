%%
%% Author: markl
%% 2/26/2018
%%

% Preamble
\documentclass[11pt]{article}
% Packages
\usepackage{a4wide}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage[open]{bookmark}
\usepackage{amsmath}
\usepackage{colonequals}
\usepackage{xcolor}

\hypersetup{
colorlinks,
citecolor=black,
filecolor=black,
linkcolor=black,
urlcolor=black
}

\title{\bfseries Call-Control in Ringnetzwerken}
\author{Michael Markl}
\date{Seminar\\ \glqq Algorithmen und Datenstrukturen\grqq\\~ \\Sommersemester 2018\\~\\ Universität Augsburg}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\theoremstyle{theorem}
\newtheorem{lemma}{Lemma}[section]
\theoremstyle{theorem}
\newtheorem{theorem}{Theorem}[section]
\newcommand{\coloniff}{\vcentcolon\Longleftrightarrow}
\newcommand\todo[1]{\textcolor{red}{#1}}
\newcommand{\set}{\mathbb}
\newcommand{\find}{\text{\em find}}
\newcommand{\Mod}{~\mathrm{mod}~}



% Document
\begin{document}
    \maketitle


    \section{Einführung}\label{sec:einführung}

    \begin{definition}[Call-Control-Problem]
        Sei $(V,E)$ ein ungerichteter Graph, dessen Kanten die Kapazitäten $c: E \to \mathbb{N}$ besitzen, und $P$ eine
        (Multi-)Menge von $m \in \mathbb{N}$ Pfaden in $(V,E)$.
        Eine Menge $Q \subseteq P$ heißt {\em geeignet}, falls für jede Kante $e \in E$ die Anzahl aller Pfade in $Q$,
        die $e$ enthalten, höchstens $c(e)$ ist.
        Die Pfade einer geeigneten Menge heißen $akzeptiert$.
        Das {\em Call-Control-Problem} besteht darin, die Anzahl der akzeptierten Pfade zu maximieren.
    \end{definition}

    Im Speziellen betrachten wir das Call-Control-Problem in Ringen und Ketten.
    Eine {\em Kette} ist ein ungerichteter Graph $(V,E)$, der nur aus den Kanten und Knoten eines Weges besteht.
    Ein {\em Ring} ist dabei ein ungerichteter Graph, der nur aus den Kanten und Knoten eines Zyklus' besteht.
    Betrachten wir einen Ring $(V,E)$ mit $V=\{0, \dots , n-1\}$ aufgezeichnet auf einer Ebene, bei dem die Knoten nach
    dem Uhrzeigersinn nummeriert werden, können wir jeden Pfad im Ring durch einen Anfangs- und Zielknoten identifizieren,
    wobei der Pfad vom Anfangsknoten aus im Uhrzeigersinn bis zum Zielknoten \glqq verläuft\grqq.
    Für einen Pfad $p$ in einem solchen Ring oder einer Kette, nennen wir $s_p$ den
    Anfangsknoten und $t_p$ den Zielknoten des Pfades und schreiben $p=(s_p, t_p)$.


    \subsection{Motivation und Anwendungen}\label{subsec:motivationUndAnwendungen}
    Diese Problemstellung findet seine Anwendung darin, in einem (Kommunikations-)Netzwerk mit festen Bandbreiten jeder
    Kante und einer gegebenen Menge an Anfragen möglichst viele dieser Anfragen zuzulassen, wobei jede Anfrage auf allen
    Kanten ihres Pfades genau eine Bandbreiteneinheit aufbraucht und keine Kante ihre Bandbreite überschreiten kann.

    Oft trifft man zwar auf die online-Variante des Problems, das heißt, dass jede Anfrage schon bei Eintreffen und
    ohne Wissen über künftige Anfragen akzeptiert oder abgelehnt werden muss.
    Jedoch sind die Erkenntnisse über das offline-Problem auch hier relevant, um eine entsprechende Lösung für das
    online-Problem entwerfen zu können.
    Außerdem kann die optimale Lösung des offline-Problems als Vergleichspunkt bei der Bewertung von Lösungen des
    online-Problems genutzt werden.

    Eine Anwendung bietet das Problem der zyklischen Ablaufplanung:

    \todo{Kette ist schon durchnummeriert definiert}

	\section{Optimale Lösung des Call-Control-Problems in Ketten}\label{sec:call-control-in-chains}
	\input{call-control-in-chains}

    \section{Lösung in Ringen}\label{sec:call-control-in-rings}
    \input{call-control-in-rings}

    \section{Gewichtetes Call-Control-Problem}\label{sec:weighted-call-control}
    Nachdem wir nun optimale Lösungen für das Call-Control-Problem in Ketten und Ringen gefunden haben, modifizieren
    wir in diesem Kapitel die Problemstellung ein wenig.
    So geben wir nun jedem der Pfade $p$ in einer Kette oder einem Ring ein besimmtes Gewicht $\lambda_p$ und versuchen
    nun, statt der Anzahl der akzeptierten Pfade, das Gesamtgewicht $\sum_{p\in Q}\lambda_p$ zu maximieren, ohne dabei
    die Kapazität einer Kante zu verletzen.
    Dabei verbraucht weiterhin jeder Pfad eine Kapazitätseinheit einer Kante, falls die Kante Teil des Pfades ist.

    Wir werden dazu für das Problem in Ketten einen optimalen Algorithmus finden, jedoch für das Problem in Ringen
    nur Approximationsalgorithmen kennenlernen. \todo{PTAS? BIPARTITE?}


\end{document}
